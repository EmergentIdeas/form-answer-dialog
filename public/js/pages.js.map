{"version":3,"file":"pages.js","mappings":";;;;;;;;AAAA,mBAAmB,mBAAO,CAAC,uEAAqB;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;;;;AAIA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,eAAe,kBAAkB,aAAa;AACxE;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,4BAA4B,QAAQ,QAAQ;AACvE;AACA;AACA;AACA,sCAAsC;AACtC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACrMA,sBAAsB,mBAAO,CAAC,yFAAsB;AACpD,yBAAyB,mBAAO,CAAC,kGAAyB;AAC1D,uBAAuB,mBAAO,CAAC,4FAAuB;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,4FAAuB;;;AAGnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,WAAW,KAAK,GAAG,MAAM,GAAG,IAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK,GAAG,OAAO;AAC1B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;;AAGA;;;;;;;;;;;;;;;AC3PA,iEAAe,gBAAgB,oBAAoB,WAAW,cAAc,YAAY,aAAa,mBAAmB,eAAe,4BAA4B,qBAAqB,0BAA0B,4BAA4B,0BAA0B,oBAAoB,GAAG,wBAAwB,eAAe,GAAG,yBAAyB,uBAAuB,2BAA2B,WAAW,cAAc,YAAY,aAAa,8BAA8B,gBAAgB,iBAAiB,eAAe,OAAO,iCAAiC,uBAAuB,0BAA0B,eAAe,uBAAuB,4BAA4B,qBAAqB,0BAA0B,+DAA+D,GAAG,oCAAoC,wBAAwB,GAAG,sCAAsC,uBAAuB,aAAa,eAAe,gCAAgC,oBAAoB,GAAG,qCAAqC,qCAAqC,qBAAqB,oBAAoB,GAAG,qCAAqC,2BAA2B,kBAAkB,mBAAmB,kCAAkC,GAAG,qCAAqC,kCAAkC,kBAAkB,GAAG,4CAA4C,uBAAuB,GAAG,CAAC;;;;;;;;;;ACAl5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,4FAAuB;;;;AAInC;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;;AAGA;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,4FAAuB;;;AAGnC;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;;AAGA;;;;;;;;;;;AC7CA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC9CA,wBAAwB,mBAAO,CAAC,2EAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;;;;;;;;;;;AC5DA,oBAAoB,mBAAO,CAAC,qEAAkB;AAC9C,4BAA4B,mBAAO,CAAC,uFAA2B;AAC/D,wBAAwB,mBAAO,CAAC,+EAAuB;;AAEvD;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,UAAU;AACtB,YAAY,QAAQ;AACpB;AACA,4CAA4C,sCAAsC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;;;;AC1OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACzEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,mBAAO,CAAC,2EAAqB;AACpD,oBAAoB,mBAAO,CAAC,qEAAkB;;;AAG9C;AACA,yBAAyB;AACzB;AACA;AACA;AACA,IAAI;AACJ;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA,IAAI,IAA6B;AACjC;AACA;AACA,KAAK,EAEJ;;AAED,WAAW,qBAAM;AACjB,MAAM,qBAAM;AACZ,EAAE,qBAAM;AACR;AACA,MAAM,qBAAM;AACZ,EAAE,qBAAM;AACR;AACA;;;;;;;;;;;;AC/TA,UAAU,mBAAO,CAAC,2DAAY,GAAG;AACjC;;;;;;;;;;;ACAA;AACA,YAAY;AACZ,eAAe;AACf,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,EAAE;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACnE8B;AACqB;AACK;;;AAGzC,+BAA+B,sCAAM;AACpD;AACA;AACA,YAAY,QAAQ;AACpB;AACA,YAAY,QAAQ;AACpB;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gDAAiB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,uEAAc;AACvB;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;;;;;;;;;;;;;;;AChE8B;;AAEf,yBAAyB,sCAAM;AAC9C;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;;;;;;;;;;;;;;ACxCA;AACA;AACA,WAAW,aAAa;AACxB;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtBgC;;AAEzB,eAAe;;;;;;SCFtB;SACA;;SAEA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;;SAEA;SACA;;SAEA;SACA;SACA;;;;;UCtBA;UACA;UACA;UACA;UACA,yCAAyC,wCAAwC;UACjF;UACA;UACA;;;;;UCPA;UACA;UACA;UACA;UACA,GAAG;UACH;UACA;UACA,CAAC;;;;;UCPD;;;;;UCAA;UACA;UACA;UACA,uDAAuD,iBAAiB;UACxE;UACA,gDAAgD,aAAa;UAC7D;;;;;;;;;;;;;;;ACN6B;AAC0B;AACY;AACb;;AAEtD;AACA;AACA;AACA,mBAAmB,0EAAgB;AACnC;AACA,WAAW,kEAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA,mBAAmB,mEAAU;AAC7B;AACA;;AAEA,GAAG;AACH;;AAEA,EAAE;AACF,C","sources":["webpack://@webhandle/form-answer-dialog/./node_modules/ei-dialog/dialog.js","webpack://@webhandle/form-answer-dialog/./node_modules/form-value-injector/form-value-injector.js","webpack://@webhandle/form-answer-dialog/./node_modules/input-value-injector/input-value-injector.js","webpack://@webhandle/form-answer-dialog/./node_modules/ei-dialog/dialog-styles.txt","webpack://@webhandle/form-answer-dialog/./node_modules/select-value-injector/select-value-injector.js","webpack://@webhandle/form-answer-dialog/./node_modules/textarea-value-injector/textarea-value-injector.js","webpack://@webhandle/form-answer-dialog/./node_modules/tripartite/active-element.js","webpack://@webhandle/form-answer-dialog/./node_modules/tripartite/calculate-relative-path.js","webpack://@webhandle/form-answer-dialog/./node_modules/tripartite/evaluate-in-context.js","webpack://@webhandle/form-answer-dialog/./node_modules/tripartite/execution-context.js","webpack://@webhandle/form-answer-dialog/./node_modules/tripartite/resolve-data-path.js","webpack://@webhandle/form-answer-dialog/./node_modules/tripartite/tripartite.js","webpack://@webhandle/form-answer-dialog/./views/test-form.tri","webpack://@webhandle/form-answer-dialog/./node_modules/value-injector-common/value-injector-common.js","webpack://@webhandle/form-answer-dialog/./client-lib/form-answer-dialog.mjs","webpack://@webhandle/form-answer-dialog/./client-lib/info-dialog.mjs","webpack://@webhandle/form-answer-dialog/./node_modules/@webhandle/gather-form-data/gather-form-data.mjs","webpack://@webhandle/form-answer-dialog/./views/load-browser-views.js","webpack://@webhandle/form-answer-dialog/webpack/bootstrap","webpack://@webhandle/form-answer-dialog/webpack/runtime/define property getters","webpack://@webhandle/form-answer-dialog/webpack/runtime/global","webpack://@webhandle/form-answer-dialog/webpack/runtime/hasOwnProperty shorthand","webpack://@webhandle/form-answer-dialog/webpack/runtime/make namespace object","webpack://@webhandle/form-answer-dialog/./client-js/pages.mjs"],"sourcesContent":["let dialogStyles = require('./dialog-styles.txt')\nlet sequence = 0\n\n// If we're loading via a module system or packed by webpack, we may\n// have a module here instead of the value. We need to check for default\n// and use that if it exists.\nif(typeof dialogStyles !== 'string' && dialogStyles.default) {\n\tdialogStyles = dialogStyles.default\t\n}\n\n\n/**\n * A button definition.\n * @typedef {Object} Button\n * @property {string} classes Classes to add to the button\n * @property {string} label Text shown to the user\n */\n\n\n\n/**\n * A whole page dialog. \n * @param {object} options \n * @param {string,function} options.body The contents of the body section. This can be a string,\n * in which case it will just be inserted into the body. It can be a function, in which case\n * it is expected to return a string (which will be inserted) or a Promise, which should resolve to\n * a string, which will be inserted. However, this function is passed the body element and dialog\n * object as arguments, so it can also modify content directory and return an empty string.\n * @param {object} options.on An object which the key is the selector and the value is a funtion\n * which is called when the object with that selector is clicked. If the function returns false the\n * dialog will not be closed. If it returns a Promise, the promise will be resolved and if the resolved\n * value is false, it will not be closed. Any other return condition will result in the dialog being\n * closed.\n * @param {Button[]} options.buttons The buttons that will show up in the footer of the dialog. If buttons are not\n * specified, \"OK\" and \"Cancel\" buttons will be added.\n * @param {string} options.title The title of the dialog\n * @param {string} options.dialogFrameClass An additional string inserted into the class attribute for\n * specific styling of specific types of dialog boxes.\n * @param {function} options.afterOpen A function which is called after open with the body element and dialog object\n * as arguments.\n */\nvar Dialog = function(options) {\n\tthis.id = \"dialog\" + (new Date().getTime()) + (sequence++)\n\tObject.assign(this, options)\n\tif(!this.on) {\n\t\tthis.on = {}\n\t}\n\tif(!this.on['.btn-cancel']) {\n\t\tthis.on['.btn-cancel'] = function() {\n\t\t}\n\t}\n\tif(!this.on['.btn-close']) {\n\t\tthis.on['.btn-close'] = function() {\n\t\t}\n\t}\n\t\n\tif(!options.buttons) {\n\t\tthis.buttons = [\n\t\t\t{\n\t\t\t\tclasses: 'btn btn-primary btn-ok',\n\t\t\t\tlabel: 'OK'\n\t\t\t},\n\t\t\t{\n\t\t\t\tclasses: 'btn btn-cancel',\n\t\t\t\tlabel: 'Cancel'\n\t\t\t}\n\t\t]\n\t}\n\t\n\tthis.body = options.body\n}\n\nDialog.prototype.getBodySelector = function() {\n\treturn '#' + this.id + ' .body'\n}\n\nDialog.prototype.getFrameSelector = function() {\n\treturn '#' + this.id \n}\n\nDialog.prototype.addStylesIfNeeded = function() {\n\tif(!document.querySelector('#dialog-frame-styles')) {\n\t\tdocument.querySelector('head').insertAdjacentHTML('beforeend', \n\t\t\t'<style type=\"text/css\" id=\"dialog-frame-styles\">' +\n\t\t\tdialogStyles + \n\t\t\t'</style>')\n\t}\n}\n\nDialog.prototype.renderButton = function(button) {\n\treturn `<button class=\"${button.classes}\" type=\"button\">${button.label}</button>`\n}\n\nDialog.prototype.generateFrame = function() {\n\tlet buttons = this.buttons.map(this.renderButton).join('')\n\t\n\treturn `\n<div class=\"dialog-frame ${this.dialogFrameClass || ''}\" id=\"${this.id}\" >\n\t<div class=\"mask\">\n\t</div>\n\t<div class=\"the-dialog\">\n\t\t<div class=\"close btn-close\">&times;</div>\n\t\t<div class=\"head\">\n\t\t\t${this.title}\n\t\t</div>\n\t\t<div class=\"body\">\n\t\t</div>\n\t\t<div class=\"foot\">\n\t\t\t${buttons}\n\t\t</div>\n\t</div>\n</div>\n\t`\n}\n\nDialog.prototype.open = function() {\n\tlet self = this\n\tthis.addStylesIfNeeded()\n\tdocument.querySelector('body').insertAdjacentHTML('beforeend', this.generateFrame())\n\t\n\tlet bodySelector = this.getBodySelector()\n\tlet frameSelector = this.getFrameSelector()\n\t\n\tlet bodyContent\n\tlet bodyElement = document.querySelector(bodySelector)\n\tlet frameElement = document.querySelector(frameSelector)\n\n\t\n\t\n\tframeElement.addEventListener('click', function(evt) {\n\t\tfor(let selector in self.on) {\n\t\t\tlet target = frameElement.querySelector(selector)\n\t\t\tif(evt.target == target) {\n\t\t\t\tlet result = self.on[selector]()\n\t\t\t\tif(typeof result === 'boolean') {\n\t\t\t\t\tif(result) {\n\t\t\t\t\t\tself.close()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(typeof Promise === 'function' && result instanceof Promise) {\n\t\t\t\t\tresult.then(function(result) {\n\t\t\t\t\t\tif(result !== false) {\n\t\t\t\t\t\t\tself.close()\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tself.close()\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t})\n\t\n\tfunction afterOpenResizeSetup() {\n\t\tsetTimeout(function() {\n\t\t\tlet head = document.querySelector(frameSelector + ' .head').clientHeight \n\t\t\tlet foot = document.querySelector(frameSelector + ' .foot').clientHeight\n\t\t\tlet topAndBottom = head + foot\n\n\t\t\tbodyElement.style.maxHeight = 'calc(90vh - ' + topAndBottom + 'px)'\n\t\t\tframeElement.classList.add('open')\n\t\t\t\n\t\t\tif(self.afterOpen) {\n\t\t\t\tself.afterOpen(bodyElement, self)\n\t\t\t}\n\t\t})\n\t}\n\t\n\tif(typeof this.body === 'function') {\n\t\tbodyContent = this.body(bodyElement, this)\n\t}\n\telse if(typeof this.body == 'string') {\n\t\tbodyContent = this.body\n\t}\n\n\tif(typeof bodyContent === 'string') {\n\t\tbodyElement.insertAdjacentHTML('beforeend', bodyContent)\n\t\tafterOpenResizeSetup()\n\t}\n\telse if(typeof Promise === 'function' && bodyContent instanceof Promise) {\n\t\tbodyContent.then(function(content) {\n\t\t\tbodyElement.insertAdjacentHTML('beforeend', content)\n\t\t\tafterOpenResizeSetup()\n\t\t})\n\t}\n\t\n\n\treturn this\n}\n\nDialog.prototype.close = function() {\n\tlet frame = document.querySelector(this.getFrameSelector())\n\tframe.remove()\n\treturn this\n}\n\nmodule.exports = Dialog\n\n","\nconst inputInjector = require('input-value-injector')\nconst textareaInjector = require('textarea-value-injector')\nconst selectInjector = require('select-value-injector')\n\nlet injectValues = function(text, values) {\n\t\n\tlet result = inputInjector(text, values)\n\tresult = textareaInjector(result, values)\n\tresult = selectInjector(result, values)\n\t\n\t\n\treturn result\n}\n\nmodule.exports = injectValues","const {\n\tevalFunction\n\t, attributeEscapes\n\t, fetchValue\n\t, isOrContains\n\t, escForRegex\n\t, escapeAttributeValue\n} = require('value-injector-common')\n\n\nfunction makeDate(date) {\n\tif(date instanceof Date) {\n\t\treturn date\n\t}\n\treturn new Date(date)\n}\n\nfunction pad(value, len, pad) {\n\tvalue = '' + value\n\twhile(value.length < len) {\n\t\tvalue = pad + value\n\t}\n\treturn value\n}\n\nfunction formatDate(date) {\n\tdate = makeDate(date)\n\tlet year = date.getFullYear()\n\tlet month = pad(date.getMonth() + 1, 2, '0')\n\tlet day = pad(date.getDate(), 2, '0')\n\n\treturn `${year}-${month}-${day}`\n}\nfunction formatTime(date) {\n\tdate = makeDate(date)\n\tlet hour = pad(date.getHours(), 2, '0')\n\tlet minute = pad(date.getMinutes(), 2, '0')\n\tlet sec = pad(date.getSeconds(), 2, '0')\n\tlet milli = pad(date.getMilliseconds(), 4, '0')\n\treturn `${hour}:${minute}`\n}\n\nfunction formatCombined(date) {\n\treturn formatDate(date) + 'T' + formatTime(date)\n}\n\nlet nameAttrPattern = /\\sname=[\"'](.*?)[\"']/i\nlet valAttrPattern = /\\svalue=[\"'](.*?)[\"']/i\nlet typeAttrPattern = /\\stype=[\"'](.*?)[\"']/i\nlet inputPattern = /(<input.*?>)/i\nlet checkedAttrPattern = /\\schecked(=[\"'](.*?)[\"'])?/i\n\n\nlet injectValues = function(text, values) {\n\t\n\tlet result = ''\n\t\n\ttext.split(inputPattern).forEach((item) => {\n\t\tif(item.toLowerCase().indexOf('<input') == 0) {\n\t\t\tlet r = item.match(nameAttrPattern)\n\t\t\tlet name = r ? r[1] : null\n\t\t\t\n\t\t\tr = item.match(typeAttrPattern)\n\t\t\tlet type = (r ? r[1] : 'text').toLowerCase()\n\t\t\t\n\t\t\t\n\t\t\tif(type === 'text' || type === 'hidden' || type === 'date' || type === 'time' || type === 'datetime-local'\n\t\t\t|| type === 'search' || type === 'email' || type === 'number' || type === 'tel' || type === 'url' \n\t\t\t|| type === 'month' || type === 'week' || type === 'color' || type === 'week'\n\t\t\t) {\n\t\t\t\tr = item.match(valAttrPattern)\n\t\t\t\tlet value = r ? r[1] : null\n\t\t\t\t\n\t\t\t\tlet newVal = fetchValue(values, name)\n\t\t\t\tif(type === 'date') {\n\t\t\t\t\tif(newVal) {\n\t\t\t\t\t\tlet orgValue = newVal\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tnewVal = formatDate(newVal)\n\t\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\t\tnewVal = orgValue\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(newVal == 'Invalid date') {\n\t\t\t\t\t\t\tnewVal = orgValue\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(type === 'time') {\n\t\t\t\t\tif(newVal) {\n\t\t\t\t\t\tlet orgValue = newVal\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tnewVal = formatTime(newVal)\n\t\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\t\tnewVal = orgValue\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(newVal == 'Invalid date') {\n\t\t\t\t\t\t\tnewVal = orgValue\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(type === 'datetime-local') {\n\t\t\t\t\tif(newVal) {\n\t\t\t\t\t\tlet orgValue = newVal\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tnewVal = formatCombined(newValue)\n\t\t\t\t\t\t} catch(e) {}\n\t\t\t\t\t\tif(newVal == 'Invalid date') {\n\t\t\t\t\t\t\tnewVal = orgValue\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tlet replacementText\n\t\t\t\tif(newVal === null || newVal === undefined) {\n\t\t\t\t\treplacementText = ''\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnewVal = escapeAttributeValue(newVal)\n\t\t\t\t\treplacementText = ' value=\"' + newVal + '\"'\n\t\t\t\t}\n\n\n\t\t\t\tif(value != null) {\n\t\t\t\t\tif(newVal != null) {\n\t\t\t\t\t\titem = item.replace(valAttrPattern, replacementText)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(item.endsWith('/>')) {\n\t\t\t\t\t\titem = item.slice(0, -2)\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\titem = item.slice(0, -1)\n\t\t\t\t\t}\n\t\t\t\t\titem = item + replacementText + ' />'\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tresult += item\n\t\t\t}\n\t\t\telse if(type === 'radio') {\n\t\t\t\tr = item.match(valAttrPattern)\n\t\t\t\tlet value = r ? r[1] : null\n\t\t\t\tlet newVal = fetchValue(values, name)\n\t\t\t\t\n\t\t\t\tif(!value) {\n\t\t\t\t\t// We don't have a specific value, so we'll say it's checked\n\t\t\t\t\t// if the new value is truthy.\n\t\t\t\t\t\n\t\t\t\t\tif(!newVal || newVal == 'false' || newVal == 'off') {\n\t\t\t\t\t\titem = item.replace(checkedAttrPattern, '')\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// so we should have it checked\n\t\t\t\t\t\tif(!item.match(checkedAttrPattern)) {\n\t\t\t\t\t\t\tif(item.endsWith('/>')) {\n\t\t\t\t\t\t\t\titem = item.slice(0, -2)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\titem = item.slice(0, -1)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\titem = item + ' checked=\"checked\" />'  \n\t\t\t\t\t\t}\n\t\t\t\t\t\t// if the above were not true, it's because it's already checked\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(!newVal || newVal != value) {\n\t\t\t\t\t\t// if the new value is blank or does not equal the value in\n\t\t\t\t\t\t// in the value attribute, we'll make it unchecked\n\t\t\t\t\t\titem = item.replace(checkedAttrPattern, '')\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// so we should have it checked\n\t\t\t\t\t\tif(!item.match(checkedAttrPattern)) {\n\t\t\t\t\t\t\tif(item.endsWith('/>')) {\n\t\t\t\t\t\t\t\titem = item.slice(0, -2)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\titem = item.slice(0, -1)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\titem = item + ' checked=\"checked\" />'  \n\t\t\t\t\t\t}\n\t\t\t\t\t\t// if the above were not true, it's because it's already checked\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tresult += item\n\t\t\t}\n\t\t\telse if(type === 'checkbox') {\n\t\t\t\tr = item.match(valAttrPattern)\n\t\t\t\tlet value = r ? r[1] : null\n\t\t\t\tlet newVal = fetchValue(values, name)\n\t\t\t\t\n\t\t\t\tif(!value) {\n\t\t\t\t\t// We don't have a specific value, so we'll say it's checked\n\t\t\t\t\t// if the new value is truthy.\n\t\t\t\t\t\n\t\t\t\t\tif(!newVal || isOrContains('false', newVal) || isOrContains('off', newVal)) {\n\t\t\t\t\t\titem = item.replace(checkedAttrPattern, '')\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// so we should have it checked\n\t\t\t\t\t\tif(!item.match(checkedAttrPattern)) {\n\t\t\t\t\t\t\tif(item.endsWith('/>')) {\n\t\t\t\t\t\t\t\titem = item.slice(0, -2)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\titem = item.slice(0, -1)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\titem = item + ' checked=\"checked\" />'  \n\t\t\t\t\t\t}\n\t\t\t\t\t\t// if the above were not true, it's because it's already checked\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(!newVal || !isOrContains(value, newVal)) {\n\t\t\t\t\t\t// if the new value is blank or does not equal the value in\n\t\t\t\t\t\t// in the value attribute, we'll make it unchecked\n\t\t\t\t\t\titem = item.replace(checkedAttrPattern, '')\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// so we should have it checked\n\t\t\t\t\t\tif(!item.match(checkedAttrPattern)) {\n\t\t\t\t\t\t\tif(item.endsWith('/>')) {\n\t\t\t\t\t\t\t\titem = item.slice(0, -2)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\titem = item.slice(0, -1)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\titem = item + ' checked=\"checked\" />'  \n\t\t\t\t\t\t}\n\t\t\t\t\t\t// if the above were not true, it's because it's already checked\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tresult += item\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult += item\n\t\t\t}\n\t\t\t\n\t\t}\n\t\telse {\n\t\t\tresult += item\n\t\t}\n\t})\n\t\n\treturn result\n}\n\n\nmodule.exports = injectValues\n","export default \".dialog-frame {\\n\\tposition: fixed;\\n\\ttop: 0;\\n\\tbottom: 0;\\n\\tleft: 0;\\n\\tright: 0;\\n\\tz-index: 11000;\\n\\topacity: 0;\\n\\ttransition: opacity .3s;\\n\\toverflow: hidden;\\n\\t\\n\\t\\n\\tdisplay: grid;\\n\\tjustify-content: center;\\n\\talign-content: center;\\n\\tpadding: 5vh 5%;\\n}\\n\\n.dialog-frame.open {\\n\\topacity: 1;\\n}\\n\\n.dialog-frame .mask {\\n\\tposition: absolute;\\n\\tbox-sizing: border-box;\\n\\ttop: 0;\\n\\tbottom: 0;\\n\\tleft: 0;\\n\\tright: 0;\\n\\tbackground-color: #333333;\\n\\topacity: .7;\\n\\theight: 100%;\\n\\tz-index: 0;\\n\\t\\n}\\n\\n\\n.dialog-frame .the-dialog {\\n\\tposition: relative;\\n\\tdisplay: inline-block;\\n\\tz-index: 1;\\n\\tborder-radius: 5px;\\n\\tbackground-color: white;\\n\\toverflow: hidden;\\n\\ttransform: scale(.84);\\n\\ttransition: transform 0.262s cubic-bezier(.77,-1.72,.08,1);\\n}\\n\\n.dialog-frame.open .the-dialog {\\n\\ttransform: scale(1);\\n}\\n\\n.dialog-frame .the-dialog .close {\\n\\tposition: absolute;\\n\\ttop: 0px;\\n\\tright: 0px;\\n\\tpadding: 8px 10px 10px 10px;\\n\\tcursor: pointer;\\n}\\n\\n.dialog-frame .the-dialog .head {\\n\\tborder-bottom: solid #aaaaaa 1px;\\n\\tline-height: 2em;\\n\\tpadding: 0 10px;\\n}\\n\\n.dialog-frame .the-dialog .body {\\n\\tbox-sizing: border-box;\\n\\tpadding: 20px;\\n\\toverflow: auto;\\n\\tmax-height: calc(90vh - 75px);\\n}\\n\\n.dialog-frame .the-dialog .foot {\\n\\tborder-top: solid #aaaaaa 1px;\\n\\tpadding: 10px;\\n}\\n\\n.dialog-frame .the-dialog .foot button {\\n\\tmargin-right: 15px;\\n}\";","const {\n\tevalFunction\n\t, attributeEscapes\n\t, fetchValue\n\t, isOrContains\n\t, escForRegex\n\t, escapeAttributeValue\n} = require('value-injector-common')\n\n\n\nlet nameAttrPattern = /\\sname=[\"'](.*?)[\"']/i\nlet valAttrPattern = /\\svalue=[\"'](.*?)[\"']/i\nlet typeAttrPattern = /\\stype=[\"'](.*?)[\"']/i\nlet selectPattern = /(<select[\\w\\W]*?select\\w*>)/im\nlet selectedAttrPattern = /\\sselected(=[\"'](.*?)[\"'])?/i\n\n\nlet injectValues = function(text, values) {\n\t\n\tlet result = ''\n\t\n\ttext.split(selectPattern).forEach((item) => {\n\t\tif(item.toLowerCase().indexOf('<select') == 0) {\n\t\t\tlet r = item.match(nameAttrPattern)\n\t\t\tlet name = r ? r[1] : null\n\t\t\t\n\t\t\tlet newVal = fetchValue(values, name)\n\t\t\tif(typeof newVal != 'undefined' && newVal !== null) {\n\t\t\t\titem = item.replace(selectedAttrPattern, '')\n\t\t\t\tlet optionMatch = item.match( new RegExp('value=[\"\\']' + escForRegex(newVal) + '[\"\\']', 'i'))\n\t\t\t\tif(optionMatch) {\n\t\t\t\t\tlet breakIndex = item.indexOf(optionMatch[0]) + optionMatch[0].length\n\t\t\t\t\titem = item.slice(0, breakIndex) + ' selected=\"selected\" ' + item.substring(breakIndex)\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tresult += item\n\t\t}\n\t\telse {\n\t\t\tresult += item\n\t\t}\n\t})\n\t\n\treturn result\n}\n\n\nmodule.exports = injectValues\n","const {\n\tevalFunction\n\t, attributeEscapes\n\t, fetchValue\n\t, isOrContains\n\t, escForRegex\n\t, escapeAttributeValue\n} = require('value-injector-common')\n\n\nlet nameAttrPattern = /\\sname=[\"'](.*?)[\"']/i\nlet valAttrPattern = /\\svalue=[\"'](.*?)[\"']/i\nlet typeAttrPattern = /\\stype=[\"'](.*?)[\"']/i\nlet textareaPattern = /(<textarea[\\w\\W]*?textarea\\w*>)/im\nlet selectedAttrPattern = /\\sselected(=[\"'](.*?)[\"'])?/i\n\n\nlet injectValues = function(text, values) {\n\t\n\tlet result = ''\n\t\n\ttext.split(textareaPattern).forEach((item) => {\n\t\tif(item.toLowerCase().indexOf('<textarea') == 0) {\n\t\t\tlet r = item.match(nameAttrPattern)\n\t\t\tlet name = r ? r[1] : null\n\t\t\t\n\t\t\tif(name) {\n\t\t\t\tlet newVal = fetchValue(values, name)\n\t\t\t\tif(typeof newVal != 'undefined' && newVal !== null) {\n\t\t\t\t\tlet startTagEnd = item.indexOf('>')\n\t\t\t\t\tlet endTagStart = item.lastIndexOf('<')\n\t\t\t\t\titem = item.substring(0, startTagEnd + 1) + newVal + item.substring(endTagStart)\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tresult += item\n\t\t}\n\t\telse {\n\t\t\tresult += item\n\t\t}\n\t})\n\t\n\treturn result\n}\n\n\nmodule.exports = injectValues","\nconst defaultTemplateName = 'defaultTemplate'\n\nclass ActiveElement {\n\tconstructor(conditionalExpression, dataExpression, handlingExpression, tripartite) {\n\t\tthis.conditionalExpression = conditionalExpression\n\t\tthis.dataExpression = dataExpression\n\t\tthis.handlingExpression = handlingExpression || defaultTemplateName\n\t\tthis.tripartite = tripartite\n\t}\n}\n\nmodule.exports = ActiveElement","var calculateRelativePath = function(parentPath, currentPath) {\n\tif(!parentPath) {\n\t\treturn currentPath\n\t}\n\tif(!currentPath) {\n\t\treturn currentPath\n\t}\n\t\n\tif(currentPath.indexOf('../') != 0 && currentPath.indexOf('./') != 0) {\n\t\treturn currentPath\n\t}\n\t\n\tvar pparts = parentPath.split('/')\n\tvar cparts = currentPath.split('/')\n\t\n\t// trim any starting blank sections\n\twhile(pparts.length && !pparts[0]) {\n\t\tpparts.shift()\n\t}\n\twhile(cparts.length && !cparts[0]) {\n\t\tcparts.shift()\n\t}\n\t\n\tif(currentPath.indexOf('../') == 0 ) {\n\t\twhile(cparts.length && cparts[0] == '..') {\n\t\t\tpparts.pop()\n\t\t\tcparts.shift()\n\t\t}\n\t\tpparts.pop()\n\t\t\n\t\twhile(cparts.length) {\n\t\t\tpparts.push(cparts.shift())\n\t\t}\n\t\treturn pparts.join('/')\n\t}\n\tif(currentPath.indexOf('./') == 0 ) {\n\t\tcparts.shift()\n\t\tpparts.pop()\n\t\twhile(cparts.length) {\n\t\t\tpparts.push(cparts.shift())\n\t\t}\n\t\treturn pparts.join('/')\n\t}\n\t\n\treturn currentPath\n}\n\nmodule.exports = calculateRelativePath","\nconst resolveDataPath = require('./resolve-data-path')\nfunction evaluateInContext(context, expression, dataFunctions, globalData) {\n\tif (!expression) {\n\t\treturn null\n\t}\n\tif (typeof expression === 'string') {\n\t\texpression = expression.trim()\n\t}\n\n\tif (expression === '$this' || expression === 'this') {\n\t\treturn context\n\t}\n\tif (typeof context === 'object' && expression in context) {\n\t\treturn context[expression]\n\t}\n\tif (expression === '\"\"' || expression === \"''\") {\n\t\treturn ''\n\t}\n\tlet resolved = resolveDataPath(context, expression)\n\tif (resolved === null || resolved === undefined) {\n\t\tresolved = resolveDataPath({\n\t\t\t'$globals': globalData\n\t\t}, expression)\n\t}\n\tif (resolved === null || resolved === undefined) {\n\t\tresolved = _evaluateInContext.call(context, context, expression, dataFunctions, globalData)\n\t}\n\treturn resolved\n}\n\nlet evalFunction = new Function('additionalContexts',\n\t`with ({\n\t\t'$globals': additionalContexts.globalData\n\t}) {\n\t\twith (additionalContexts.dataFunctions) {\n\t\t\twith (additionalContexts.context) {\n\t\t\t\ttry {\n\t\t\t\t\treturn eval(additionalContexts.expression);\n\t\t\t\t} catch (e) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}`\n)\n\nfunction _evaluateInContext(context, expression, dataFunctions, globalData) {\n\tdataFunctions = dataFunctions || {}\n\tglobalData = globalData || {}\n\n\n\tlet result = evalFunction.call(this, {\n\t\tglobalData: globalData\n\t\t, dataFunctions: dataFunctions\n\t\t, context: context\n\t\t, expression: expression\n\t})\n\treturn result\n}\n\nmodule.exports = evaluateInContext","\nlet ActiveElement = require('./active-element')\nvar calculateRelativePath = require('./calculate-relative-path')\nlet evaluateInContext = require('./evaluate-in-context')\n\nclass ExecutionContext {\n\t/**\n\t * \n\t * @param {Tripartite} tripartite \n\t * @param {function} template \n\t * @param {stream} [destination]\n\t */\n\tconstructor(tripartite, template, data = {}, destination = '', dataFunctions = {}) {\n\t\tthis.tripartite = tripartite\n\t\tthis.template = template\n\t\tthis.destination = destination\n\t\tthis.initialData = data\n\t\tthis.currentData = []\n\t\tthis.dataFunctions = dataFunctions\n\t\tthis.continueOnTripartiteError = true\n\t\t\n\t\t// Sometimes large pages have so many elements that we exceed\n\t\t// the maximum call depth. This happens when we have a lot of elements all being\n\t\t// rendered by the same templates. That is, there's no async callback when a template\n\t\t// is loaded, only instant callbacks.\n\t\t// The downside to doing very frequent async calls is that it takes a lot longer to\n\t\t// to get called from a setTimeout than it does to call directly. We want ot keep\n\t\t// the time between needing to do that reasonably long. Unfortunately, there's no\n\t\t// easy/fast way to detect the call stack depth, so we rely on this proxy.\n\t\tthis.callCount = 0\n\t\tthis.callDepthLimit = 1000\n\t}\n\n\t/**\n\t * \n\t * @param {function} [callback] called when done\n\t * @returns Returns the string of stream as the result of the operation\n\t */\n\trun(callback) {\n\t\tlet ourCallback\n\t\tif (callback) {\n\t\t\tourCallback = () => {\n\t\t\t\tcallback(null, this.destination)\n\t\t\t}\n\t\t}\n\n\t\tthis._run(this.template, this.initialData, ourCallback)\n\n\t\treturn this.destination\n\t}\n\n\t_resolveHandlingExpression(template, handlingExpression, data) {\n\t\tif (!handlingExpression) {\n\t\t\thandlingExpression = defaultTemplateName\n\t\t}\n\t\tif (handlingExpression.charAt(0) == '$') {\n\t\t\t// Indicates the handling espression is not a literal template name but is a string which should\n\t\t\t// be evaluated to determine the template name\n\t\t\thandlingExpression = evaluateInContext(data, handlingExpression.substring(1), this.dataFunctions, this.initialData)\n\t\t}\n\t\t// resolve relative template paths\n\t\tif (handlingExpression.indexOf('./') == 0 || handlingExpression.indexOf('../') == 0) {\n\t\t\thandlingExpression = calculateRelativePath(template.templateMeta.name, handlingExpression)\n\t\t}\n\n\t\treturn handlingExpression\n\t}\n\n\t_run(template, data, callback) {\n\t\tlet parts = [...template.parts].reverse()\n\t\tconst processParts = () => {\n\t\t\t\n\t\t\t// check to see how far down in the call stack we are. If too far down,\n\t\t\t// come back in the next tick.\n\t\t\tthis.callCount++\n\t\t\tif(this.callCount++ > this.callDepthLimit) {\n\t\t\t\tsetTimeout(()=> {\n\t\t\t\t\tthis.callCount = 0\n\t\t\t\t\tprocessParts()\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (parts.length > 0) {\n\t\t\t\tlet part = parts.pop()\n\t\t\t\tif (typeof part === 'string') {\n\t\t\t\t\tthis.output(part)\n\t\t\t\t\tprocessParts()\n\t\t\t\t}\n\t\t\t\telse if (part instanceof ActiveElement) {\n\t\t\t\t\tlet conditional = part.conditionalExpression || part.dataExpression\n\t\t\t\t\tlet conditionalResult = false\n\t\t\t\t\tlet resultData\n\t\t\t\t\tif (conditional == null || conditional == undefined || conditional === '') {\n\t\t\t\t\t\t// Because if they didn't specify a condition or data, they probably \n\t\t\t\t\t\t// just want the template to be run as is\n\t\t\t\t\t\tconditionalResult = true\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(part.conditionalExpression) {\n\t\t\t\t\t\t\tlet result = evaluateInContext(data, part.conditionalExpression, this.dataFunctions, this.initialData)\n\t\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\t\tconditionalResult = true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// This means we're evaluating the data expression to see if we should run the template\n\t\t\t\t\t\t\tresultData = evaluateInContext(data, part.dataExpression, this.dataFunctions, this.initialData)\n\t\t\t\t\t\t\tif(resultData === null || resultData === undefined) {\n\t\t\t\t\t\t\t\tconditionalResult = false\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (typeof resultData === 'number') {\n\t\t\t\t\t\t\t\t// if the result is a number, any number, we want to output it\n\t\t\t\t\t\t\t\t// unless the number is from the conditional expression, in which\n\t\t\t\t\t\t\t\t// case we want to evaluate it as truthy\n\t\t\t\t\t\t\t\tconditionalResult = true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(Array.isArray(resultData) && resultData.length > 0) {\n\t\t\t\t\t\t\t\tconditionalResult = true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(resultData) {\n\t\t\t\t\t\t\t\tconditionalResult = true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif (conditionalResult) {\n\t\t\t\t\t\tif (part.dataExpression && resultData === undefined) {\n\t\t\t\t\t\t\tresultData = evaluateInContext(data, part.dataExpression, this.dataFunctions, this.initialData)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif((resultData === null || resultData === undefined) && !part.dataExpression) {\n\t\t\t\t\t\t\tresultData = data\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet handlingExpression = this._resolveHandlingExpression(template, part.handlingExpression, data)\n\t\t\t\t\t\tlet handlingTemplate\n\t\t\t\t\t\tlet children = (Array.isArray(resultData) ? [...resultData] : [resultData]).reverse()\n\t\t\t\t\t\tconst applyTemplate = () => {\n\t\t\t\t\t\t\tif (children.length > 0) {\n\t\t\t\t\t\t\t\tlet child = children.pop()\n\t\t\t\t\t\t\t\tthis._run(handlingTemplate, child, () => {\n\t\t\t\t\t\t\t\t\tapplyTemplate()\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tprocessParts()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(handlingExpression in this.tripartite.templates) {\n\t\t\t\t\t\t\thandlingTemplate = this.tripartite.getTemplate(handlingExpression)\n\t\t\t\t\t\t\tif (handlingTemplate) {\n\t\t\t\t\t\t\t\tapplyTemplate()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// the template has been loaded before but is empty\n\t\t\t\t\t\t\t\tif (this.continueOnTripartiteError) {\n\t\t\t\t\t\t\t\t\tprocessParts()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthis.tripartite.loadTemplate(handlingExpression, (template) => {\n\t\t\t\t\t\t\t\tif (!template) {\n\t\t\t\t\t\t\t\t\tlet msg = 'Could not load template: ' + handlingExpression\n\t\t\t\t\t\t\t\t\tconsole.error(msg)\n\t\t\t\t\t\t\t\t\tif (this.continueOnTripartiteError) {\n\t\t\t\t\t\t\t\t\t\tprocessParts()\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tlet err = new Error(msg)\n\t\t\t\t\t\t\t\t\t\tif (callback) {\n\t\t\t\t\t\t\t\t\t\t\tcallback(err)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tthrow err\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\thandlingTemplate = template\n\t\t\t\t\t\t\t\t\tapplyTemplate()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tprocessParts()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (typeof part === 'function') {\n\t\t\t\t\tif(part.write) {\n\t\t\t\t\t\tpart.write(data, this.destination, () => {\n\t\t\t\t\t\t\tprocessParts()\n\t\t\t\t\t\t})\n\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.output(part(data))\n\t\t\t\t\t\tprocessParts()\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprocessParts()\n\t}\n\n\t/**\n\t * \n\t * @param {string} value \n\t */\n\toutput(value) {\n\t\tif(value === null || value === undefined) {\n\t\t\treturn\n\t\t}\n\t\tif (typeof this.destination === 'string') {\n\t\t\tthis.destination += value\n\t\t}\n\t\telse if (this.destination.write) {\n\t\t\tthis.destination.write(value)\n\t\t}\n\t}\n}\n\n\nmodule.exports = ExecutionContext","/*\nfunction resolveDataPath(data, path) {\n\tif(data === null || data === undefined) {\n\t\treturn data\n\t}\n\tlet parts\n\tif(typeof path === 'string') {\n\t\tparts = path.trim().split('.')\n\t}\n\telse if(Array.isArray(path)) {\n\t\tparts = path\n\t}\n\t\n\tlet name = parts.shift()\n\tif(name.indexOf(' ') > -1) {\n\t\t// there's a space, which means it's really unlikely it's a property\n\t\treturn null\n\t}\n\tlet child\n\tif(name === 'this' || name === '$this') {\n\t\tchild = data\n\t}\n\telse if(typeof data === 'object') {\n\t\tif(name in data) {\n\t\t\tchild = data[name]\n\t\t}\n\t}\n\tif(parts.length > 0) {\n\t\treturn resolveDataPath(child, parts)\n\t}\n\telse {\n\t\treturn child\n\t}\n} */\nfunction resolveDataPath(data, path) {\n\ttry {\n\t\tif (data === null || data === undefined) {\n\t\t\treturn data\n\t\t}\n\t\tlet parts\n\t\tif (typeof path === 'string') {\n\t\t\tparts = path.trim().split('.')\n\t\t}\n\t\telse if (Array.isArray(path)) {\n\t\t\tparts = path\n\t\t}\n\n\t\twhile (parts.length > 0) {\n\t\t\tlet name = parts.shift()\n\t\t\tif (name.indexOf(' ') > -1) {\n\t\t\t\t// there's a space, which means it's really unlikely it's a property\n\t\t\t\treturn null\n\t\t\t}\n\t\t\tlet child\n\t\t\tif (name === 'this' || name === '$this') {\n\t\t\t\tchild = data\n\t\t\t}\n\t\t\telse if (typeof data === 'object') {\n\t\t\t\tif (name in data) {\n\t\t\t\t\tchild = data[name]\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (parts.length == 0) {\n\t\t\t\treturn child\n\t\t\t}\n\t\t\tif (child === null || child === undefined) {\n\t\t\t\treturn null\n\t\t\t}\n\t\t\tdata = child\n\t\t}\n\t}\n\tcatch (e) {\n\t\treturn null\n\t}\n}\n\nmodule.exports = resolveDataPath","\n\n\nif (typeof String.prototype.trim !== 'function') {\n\tString.prototype.trim = function () {\n\t\treturn this.replace(/^\\s+|\\s+$/g, '');\n\t}\n}\n\n\nfunction isStream(stream) {\n\treturn stream !== null\n\t\t&& typeof stream === 'object'\n\t\t&& typeof stream.pipe === 'function';\n}\n\n\nfunction isTemplate(obj) {\n\tif (!obj) {\n\t\treturn false\n\t}\n\tif (typeof obj !== 'function') {\n\t\treturn false\n\t}\n\tif (!obj.write) {\n\t\treturn false\n\t}\n\tif (!obj.parts) {\n\t\treturn false\n\t}\n\tif (!obj.templateMeta) {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nlet ExecutionContext = require('./execution-context')\nlet ActiveElement = require('./active-element')\n\n\nclass Tripartite {\n\tconstructor(options = {}) {\n\t\tthis.templates = {\n\t\t\tdefaultTemplate: this._makeTemplate(function (thedata) {\n\t\t\t\treturn '' + thedata;\n\t\t\t})\n\t\t}\n\t\tlet { constants = {\n\t\t\ttemplateBoundary: '__',\n\t\t\ttemplateNameBoundary: '##'\n\t\t} } = options\n\t\tthis.constants = constants\n\n\t\t// This object (if set) will receive the template functions parsed from a script\n\t\t// I want to be able to call my templates as global functions, so I've set it\n\t\t// to be the window object\n\t\tthis.secondaryTemplateFunctionObject = options.secondaryTemplateFunctionObject\n\n\t\tthis.loaders = options.loaders || []\n\n\t\tthis.dataFunctions = options.dataFunction || {}\n\t}\n\n\t_makeTemplate(transformationFunction) {\n\t\tif (isTemplate(transformationFunction)) {\n\t\t\treturn transformationFunction\n\t\t}\n\t\tlet tri = this\n\t\tlet f = function (thedata) {\n\t\t\tlet stream = null\n\t\t\tlet options = null\n\t\t\tlet callback = null\n\t\t\tfor (let i = 1; i < arguments.length; i++) {\n\t\t\t\tlet arg = arguments[i]\n\t\t\t\tif (isStream(arg)) {\n\t\t\t\t\tstream = arg\n\t\t\t\t}\n\t\t\t\telse if(typeof arg === 'function') {\n\t\t\t\t\tcallback = arg\n\t\t\t\t}\n\t\t\t\telse if(typeof arg === 'object') {\n\t\t\t\t\toptions = arg\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn f.write(thedata, stream, callback, options)\n\t\t}\n\t\tf.write = function (thedata, stream, callback, options = {}) {\n\t\t\tif(transformationFunction && transformationFunction.write) {\n\t\t\t\t// if it's not a template, but has a write method, invoke the right method directly\n\t\t\t\treturn transformationFunction.write.apply(transformationFunction, arguments)\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet dest = stream || ''\n\n\t\t\t\tlet context = new ExecutionContext(tri, f, thedata, dest, tri.dataFunctions)\n\t\t\t\tif (options && 'continueOnTripartiteError' in options) {\n\t\t\t\t\tcontext.continueOnTripartiteError = options.continueOnTripartiteError\n\t\t\t\t}\n\n\t\t\t\treturn context.run(callback)\n\t\t\t}\n\t\t}\n\t\tf.parts = []\n\t\tif (transformationFunction && typeof transformationFunction === 'function') {\n\t\t\tf.parts.push(transformationFunction)\n\t\t}\n\t\tf.templateMeta = {}\n\t\treturn f\n\t}\n\n\taddTemplate(name, template) {\n\t\tif (typeof template === 'string') {\n\t\t\ttemplate = this.parseTemplate(template);\n\t\t}\n\t\telse if (typeof template === 'function') {\n\t\t\ttemplate = this._makeTemplate(template)\n\t\t}\n\n\t\tthis.templates[name] = template;\n\t\ttemplate.templateMeta = template.templateMeta || {}\n\t\ttemplate.templateMeta.name = name\n\t\treturn template;\n\t}\n\n\tcreateBlank() {\n\t\treturn new Tripartite()\n\t}\n\n\tgetTemplate(name) {\n\t\treturn this.templates[name]\n\t}\n\n\tloadTemplate(name, callback) {\n\t\tif (name in this.templates) {\n\t\t\tcallback(this.templates[name])\n\t\t}\n\t\telse {\n\t\t\tlet tri = this\n\t\t\tlet count = this.loaders.length\n\t\t\tlet done = false\n\n\t\t\tif (count == 0) {\n\t\t\t\ttri.templates[name] = null\n\t\t\t\tcallback(tri.getTemplate(name))\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.loaders.forEach(loader => {\n\t\t\t\t\tif (done) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tloader(name, template => {\n\t\t\t\t\t\tif (done) {\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount--\n\t\t\t\t\t\tif (template) {\n\t\t\t\t\t\t\tdone = true\n\t\t\t\t\t\t\ttri.addTemplate(name, template)\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (count == 0) {\n\t\t\t\t\t\t\tdone = true\n\t\t\t\t\t\t\ttri.templates[name] = null\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (done) {\n\t\t\t\t\t\t\tcallback(tri.getTemplate(name))\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\tparseTemplateScript(tx) {\n\t\tvar tks = this.tokenizeTemplateScript(tx);\n\t\t/* current template name */\n\t\tvar ctn = null;\n\t\tfor (var i = 0; i < tks.length; i++) {\n\t\t\tvar token = tks[i];\n\t\t\tif (token.active) {\n\t\t\t\tctn = token.content;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (ctn) {\n\t\t\t\t\tvar template = this.addTemplate(ctn, this.stripTemplateWhitespace(token.content));\n\t\t\t\t\tif (this.secondaryTemplateFunctionObject) {\n\t\t\t\t\t\tthis.secondaryTemplateFunctionObject[ctn] = template;\n\t\t\t\t\t}\n\t\t\t\t\tctn = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstripTemplateWhitespace(txt) {\n\t\tvar i = txt.indexOf('\\n');\n\t\tif (i > -1 && txt.substring(0, i).trim() == '') {\n\t\t\ttxt = txt.substring(i + 1);\n\t\t}\n\t\ti = txt.lastIndexOf('\\n');\n\t\tif (i > -1 && txt.substring(i).trim() == '') {\n\t\t\ttxt = txt.substring(0, i);\n\t\t}\n\t\treturn txt;\n\t}\n\n\t/* simple template */\n\t_createActiveElement(/* conditional expression */ cd, data, /* handling expression */ hd, tripartite, templateMeta) {\n\t\tlet el = new ActiveElement(cd, data, hd, tripartite);\n\t\tel.templateMeta = templateMeta\n\t\treturn el\n\t}\n\tpt(tx) {\n\t\treturn this.parseTemplate(tx)\n\t}\n\t/* parse template */\n\tparseTemplate(tx) {\n\t\tvar tks = this.tokenizeTemplate(tx);\n\t\tlet t = this._makeTemplate()\n\t\tvar templateMeta = t.templateMeta\n\n\t\tfor (let tk of tks) {\n\t\t\tif (tk.active) {\n\t\t\t\tt.parts.push(this.tokenizeActivePart(tk.content, templateMeta));\n\t\t\t}\n\t\t\telse if (tk.content) {\n\t\t\t\tt.parts.push(tk.content);\n\t\t\t}\n\t\t}\n\n\t\treturn t\n\t}\n\n\ttokenizeActivePart(tx, templateMeta) {\n\t\tvar con = null;\n\t\tvar dat = null;\n\t\tvar han = null;\n\n\t\t/* condition index */\n\t\tvar ci = tx.indexOf('??');\n\t\tif (ci > -1) {\n\t\t\tcon = tx.substring(0, ci);\n\t\t\tci += 2;\n\t\t}\n\t\telse {\n\t\t\tci = 0;\n\t\t}\n\n\t\t/* handler index */\n\t\tvar hi = tx.indexOf('::');\n\t\tif (hi > -1) {\n\t\t\tdat = tx.substring(ci, hi);\n\t\t\than = tx.substring(hi + 2);\n\t\t}\n\t\telse {\n\t\t\tdat = tx.substring(ci);\n\t\t}\n\t\treturn this._createActiveElement(con, dat, han, this, templateMeta);\n\t}\n\n\ttokenizeTemplate(tx) {\n\t\treturn this.tokenizeActiveAndInactiveBlocks(tx, this.constants.templateBoundary);\n\t}\n\n\n\t/** tokenize template script */\n\ttokenizeTemplateScript(tx) {\n\t\treturn this.tokenizeActiveAndInactiveBlocks(tx, this.constants.templateNameBoundary);\n\t}\n\n\t/* tokenize active and inactive blocks */\n\ttokenizeActiveAndInactiveBlocks(text, /*Active Region Boundary */ boundary) {\n\t\t/* whole length */\n\t\tlet length = text.length\n\n\t\t/* current position */\n\t\tlet position = 0\n\n\t\t/* are we in an active region */\n\t\tlet act = false\n\n\t\tlet tokens = []\n\n\t\twhile (position < length) {\n\t\t\tlet i = text.indexOf(boundary, position);\n\t\t\tif (i == -1) {\n\t\t\t\ti = length;\n\t\t\t}\n\t\t\tvar tk = { active: act, content: text.substring(position, i) };\n\t\t\ttokens.push(tk);\n\t\t\tposition = i + boundary.length;\n\t\t\tact = !act;\n\t\t}\n\n\t\treturn tokens;\n\t}\n\n}\nvar tripartiteInstance = new Tripartite()\n\nif (typeof window != 'undefined') {\n\ttripartiteInstance.secondaryTemplateFunctionObject = window\n}\n\n\nif (typeof module !== 'undefined') {\n\tmodule.exports = tripartiteInstance\n}\nelse {\n\twindow.Tripartite = tripartiteInstance\n}\n\nif (typeof global != 'undefined') {\n\tif (!global.Tripartite) {\n\t\tglobal.Tripartite = Tripartite\n\t}\n\tif (!global.tripartite) {\n\t\tglobal.tripartite = tripartiteInstance\n\t}\n}\n\n","var tri = require(\"tripartite\"); var t = \"<label> Name\\n\\t<br>\\n\\t<input name=\\\"name\\\" type=\\\"text\\\" \\/>\\n<\\/label>\\n<br>\\n<label> Sex\\n\\t<br>\\n\\t<select name=\\\"sex\\\">\\n\\t\\t<option value=\\\"\\\">-- please choose --<\\/option>\\n\\t\\t<option value=\\\"male\\\">male<\\/option>\\n\\t\\t<option value=\\\"female\\\">female<\\/option>\\n\\t<\\/select>\\n<\\/label>\\n<br>\\n<label> Bio\\n\\t<br>\\n\\t<textarea name=\\\"bio\\\"><\\/textarea>\\n<\\/label>\\n<br>\\n<div> Newsletter\\n\\t<label>\\n\\t\\t<input name=\\\"newsletter\\\" type=\\\"checkbox\\\" \\/>\\n\\t<\\/label>\\n<\\/div>\\n<br>\\n<div> Pet\\n\\t<br>\\n\\t<label>\\n\\t\\t<input name=\\\"pets\\\" type=\\\"radio\\\" value=\\\"cats\\\" \\/> Cats\\n\\t<\\/label>\\n\\t<br>\\n\\t<label>\\n\\t\\t<input name=\\\"pets\\\" type=\\\"radio\\\" value=\\\"dogs\\\" \\/> Dogs\\n\\t<\\/label>\\n<\\/div>\"; \nmodule.exports = tri.addTemplate(\"test-form\", t); ","\nlet attributeEscapes = {\n\t'&': '&amp;'\n\t, '\"': '&quot;'\n\t, '<': '&lt;'\n}\n\nlet evalFunction = new Function('data',\n\t`with (data.context) {\n\t\ttry {\n\t\t\treturn eval(data.expression);\n\t\t} catch (e) {\n\t\t\treturn null;\n\t\t}\n\t}`\n)\n\nfunction fetchValue(obj, path) {\n\tif(typeof obj === 'null' || typeof obj === 'undefined') {\n\t\treturn null\n\t}\n\treturn evalFunction.call(this, {\n\t\tcontext: obj\n\t\t, expression: path\n\t})\n}\n\n\nfunction isOrContains(target, possible) {\n\tif(Array.isArray(possible)) {\n\t\treturn possible.includes(target)\n\t}\n\telse {\n\t\treturn target == possible\n\t}\n}\n\nfunction escForRegex(val) {\n\tif(val && val.replace) {\n\t\treturn val.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\")\n\t}\n\telse {\n\t\treturn val;\n\t}\n}\n\nfunction escapeAttributeValue(attr) {\n\tif(attr === null || attr === undefined) {\n\t\tattr = ''\n\t}\n\tif(typeof attr !== 'string') {\n\t\tattr = '' + attr\n\t}\n\tfor(let [key, value] of Object.entries(attributeEscapes)) {\n\t\tattr = attr.split(key).join(value)\n\t}\n\treturn attr\n}\n\n\nmodule.exports = {\n\tevalFunction\n\t, attributeEscapes\n\t, fetchValue\n\t, isOrContains\n\t, escForRegex\n\t, escapeAttributeValue\n}\n","import Dialog from 'ei-dialog'\nimport formValueInjector from 'form-value-injector'\nimport gatherFormData from '@webhandle/gather-form-data'\n\n\nexport default class FormAnswerDialog extends Dialog {\n\t/**\n\t * \n\t * @param {Object} options Properties to create the dialog box. In addition to the properties from Dialog\n\t * there those below.\n\t * @param {Object} options.data The data which will be used to populate the controls in the dialog\n\t */\n\tconstructor(options) {\n\t\tsuper(Object.assign({}, options,\n\t\t\t{\n\t\t\t\ton: {\n\t\t\t\t\t'.btn-ok': () => {\n\t\t\t\t\t\tthis.resolve(this.gatherData())\n\t\t\t\t\t\treturn true\n\t\t\t\t\t},\n\t\t\t\t\t'.mask': () => {\n\t\t\t\t\t\tthis.resolve()\n\t\t\t\t\t\treturn true\n\t\t\t\t\t},\n\t\t\t\t\t'.btn-cancel': () => {\n\t\t\t\t\t\tthis.resolve()\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t))\n\t\tif (this.afterOpen) {\n\t\t\tthis.afterOpenOriginal = this.afterOpen\n\t\t}\n\t\tthis.afterOpen = function (bodyElement, self) {\n\t\t\tif (this.data) {\n\t\t\t\tbodyElement.innerHTML = formValueInjector(bodyElement.innerHTML, this.data)\n\t\t\t}\n\t\t\tlet firstInput = bodyElement.querySelector('input, textarea')\n\t\t\tif (firstInput) {\n\t\t\t\tfirstInput.focus()\n\t\t\t}\n\n\t\t\tif (this.afterOpenOriginal) {\n\t\t\t\tthis.afterOpenOriginal(bodyElement, self)\n\t\t\t}\n\t\t}\n\t}\n\tgatherData() {\n\t\tlet dialogBody = document.querySelector(this.getBodySelector())\n\t\treturn gatherFormData(dialogBody)\n\t}\n\n\tasync open() {\n\t\tthis.promise = new Promise((resolve, reject) => {\n\t\t\tthis.resolve = resolve\n\t\t\tthis.reject = reject\n\t\t})\n\t\tsuper.open()\n\n\t\treturn this.promise\n\t}\n\n}","import Dialog from 'ei-dialog'\n\nexport default class InfoDialog extends Dialog {\n\tconstructor(options) {\n\t\tsuper(Object.assign({}, options,\n\t\t\t{\n\t\t\t\ton: {\n\t\t\t\t\t'.btn-ok': () => {\n\t\t\t\t\t\tthis.resolve()\n\t\t\t\t\t\treturn true\n\t\t\t\t\t},\n\t\t\t\t\t'.mask': () => {\n\t\t\t\t\t\tthis.resolve()\n\t\t\t\t\t\treturn true\n\t\t\t\t\t},\n\t\t\t\t\t'.btn-cancel': () => {\n\t\t\t\t\t\tthis.resolve()\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t, buttons: [\n\t\t\t\t\t{\n\t\t\t\t\t\tclasses: 'btn btn-primary btn-ok',\n\t\t\t\t\t\tlabel: 'OK'\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t}\n\t\t))\n\t}\n\n\tasync open() {\n\t\tthis.promise = new Promise((resolve, reject) => {\n\t\t\tthis.resolve = resolve\n\t\t\tthis.reject = reject\n\t\t})\n\t\tsuper.open()\n\n\t\treturn this.promise\n\t}\n\n}","/**\n * Gathers the data from the form controls.\n * @param {HTMLElement} formBody The html element containing the controls. Probably\n * a form tag element, but it really doesn't matter.\n */\nexport default function gatherFormData(formBody) {\n\tlet result = {}\n\tlet controls = formBody.querySelectorAll('input, textarea, select')\n\tfor (let control of controls) {\n\t\tif (control.type === 'checkbox') {\n\t\t\tif (!control.checked) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\telse if (control.type === 'radio') {\n\t\t\tif (!control.checked) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tresult[control.getAttribute('name')] = control.value\n\t}\n\treturn result\n}\n\n","import t3 from './test-form.tri'\n\nexport let testForm = t3","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import tri from 'tripartite';\nimport {testForm} from \"../views/load-browser-views.js\"\nimport FormAnswerDialog from \"../client-lib/form-answer-dialog.mjs\"\nimport InfoDialog from \"../client-lib/info-dialog.mjs\"\n\nlet formButton = document.getElementById('form-dialog-button')\nif(formButton) {\n\tformButton.addEventListener('click', async () => {\n\t\tlet dialog = new FormAnswerDialog({\n\t\t\ttitle: 'A form dialog'\n\t\t\t, body: testForm\n\t\t\t, data: {\n\t\t\t\tname: 'my name'\n\t\t\t\t, sex: 'male'\n\t\t\t\t, bio: 'He is awesome'\n\t\t\t\t, newsletter: 'on'\n\t\t\t\t, pets: 'cats'\n\t\t\t}\n\t\t})\n\n\t\tlet data = await dialog.open()\n\n\t\tif(!data) {\n\t\t\tconsole.log('Dialog was canceled.')\n\t\t}\n\t\telse {\n\t\t\tconsole.log('The data is: \\n' + JSON.stringify(data, null, '\\t'))\n\t\t}\n\t})\n}\n\nlet infoButton = document.getElementById('info-dialog-button')\nif(infoButton) {\n\tinfoButton.addEventListener('click', async () => {\n\t\tlet dialog = new InfoDialog({\n\t\t\ttitle: 'We have info!'\n\t\t\t, body: 'This is the information.'\n\n\t\t})\n\t\tawait dialog.open()\n\n\t})\n}"],"names":[],"sourceRoot":""}